Grid for
N=8: (number of intervals)

    u|  u   u   u   u   u   u   u  |u       ind: 0,...,8
     |p   p   p   p   p   p   p   p|        ind: 0,...,7

Here u are on the boundaries.
Inner u indices: 1,...,7
Inner p indices: 0,...,7

Single thread
-------------
Update function updates indices: dst1 to dst2-1.
Hence for a single threaded update:

    update_field (p, 0, 8, u, 0, f.dt);

applied to:

    u|  u   u   u   u   u   u   u  |u       ind: 0,...,8
     |p   p   p   p   p   p   p   p|        ind: 0,...,7

and

    update_field (u, 1, 7, p, 0, f.dt);

applied to:

     |p   p   p   p   p   p   p   p|        ind: 0,...,7
    u|  u   u   u   u   u   u   u  |u       ind: 0,...,8

This leaves the edge u alone.

Two threads
-----------
For two threads the partition would be

    u|  u   u   u   u|  u|  u   u  |u       ind: 0,...,8
     |p   p   p   p  |p  |p   p   p|        ind: 0,...,7

    T0: p: 0,..,4   u: 1,..,5
    T1: p: 4,..,8   u: 5,..,8

Note that p:8 doesn't actually exist, and that T1 gets assigned u point which
is not updated (it is on the boundary).
This partition update according to:

    update_field (p, 0, 4, u, 0, f.dt);     // updates p:0,..,3
    update_field (p, 4, 8, u, 4, f.dt);     // updates p:4,..,7

applied to:

    u|  u   u   u   u   u   u   u  |u   
     |p   p   p   p  |p   p   p   p|     

Note here that T1 require an u node outside its domain (u[4]). For shared
memory this is not a problem. For distributed memory T0 needs to send u[4] =
u[part.end_u-1] to the right.

Then:

    update_field (u, 1, 5, p, 0, f.dt);     // updates u:1,..,4
    update_field (u, 5, 8, p, 4, f.dt);     // updates u:5,..,7

applied to:

     |p   p   p   p   p   p   p   p|        ind: 0,...,7
    u|  u   u   u   u|  u   u   u  |u       ind: 0,...,8

In this case it is T0 which require a p node outside its domain (p[5]). Here
T1 needs to send p[5] = p[part.start_p+1] to the left.

ALTERNATIVE PARTITION FOR TWO THREADS
